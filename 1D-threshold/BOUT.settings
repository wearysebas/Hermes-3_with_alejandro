IncIntShear = false		# type: bool, source: default
MXG = 0		# type: int, doc: Number of guard cells on each side in X, source: examples/tokamak-1D/1D-threshold/BOUT.inp
MYG = 2		# type: int, doc: Number of guard cells on each side in Y, source: default
ZMAX = 1		# type: BoutReal, source: default
ZMIN = 0		# type: BoutReal, source: default
append = false		# type: bool, doc: Add new outputs to the end of existing files? If false, overwrite files., source: default
async_send = false		# type: bool, doc: Whether to use asyncronous MPI sends, source: default
datadir = examples/tokamak-1D/1D-threshold/		# type: string, source: Command line
dump_on_restart = true		# type: bool, doc: Write initial state as time point 0?, source: default
json_database_dir = /users/sr1937/scratch/hermes-3/json_database		# type: string, doc: Path to directory containing reaction data json files., source: default
non_uniform = true		# type: bool, source: default
nout = 50		# type: int, doc: Number of output steps, source: examples/tokamak-1D/1D-threshold/BOUT.inp
optionfile = BOUT.inp		# type: string, source: default
periodicX = false		# type: bool, doc: Make grid periodic in X?, source: default
restart = false		# type: bool, doc: Load state from restart files?, source: default
settingsfile = BOUT.settings		# type: string, source: default
stopCheck = false		# type: bool, doc: Check if a file exists, and exit if it does., source: default
stopCheckName = BOUT.stop		# type: string, doc: Name of file whose existence triggers a stop, source: default
timestep = 95788 * 0.05		# type: BoutReal, doc: Output time step size, source: examples/tokamak-1D/1D-threshold/BOUT.inp
twistshift = false		# type: bool, doc: Apply a Twist-Shift boundary using ShiftAngle?, source: default
wall_limit = -1		# type: BoutReal, doc: Wall time limit in hours. By default (< 0), no limit, source: default

[NVd]
evolve_bndry = false		# type: bool, source: default

[NVd+]
evolve_bndry = false		# type: bool, source: default
function = 0		# type: string, source: examples/tokamak-1D/1D-threshold/BOUT.inp

[Nd]
evolve_bndry = false		# type: bool, source: default
function = 0.001		# type: string, source: examples/tokamak-1D/1D-threshold/BOUT.inp
neumann_boundary_average_z = false		# type: bool, doc: Apply neumann boundary with Z average?, source: default
source = <Field3D>		# type: Field3D, doc: Source term in ddt(Nd). Units [m^-3/s], source: default
source_only_in_core = false		# type: bool, doc: Zero the source outside the closed field-line region?, source: default
source_time_dependent = false		# type: bool, doc: Use a time-dependent source?, source: default

[Nd+]
evolve_bndry = false		# type: bool, source: default
function = 1		# type: string, source: examples/tokamak-1D/1D-threshold/BOUT.inp
neumann_boundary_average_z = false		# type: bool, doc: Apply neumann boundary with Z average?, source: default
source = <Field3D>		# type: Field3D, doc: Source term in ddt(Nd+). Units [m^-3/s], source: default
source_only_in_core = false		# type: bool, doc: Zero the source outside the closed field-line region?, source: default
source_shape = H(mesh:y_xpt - y) * 1e20		# type: Field3D, doc: Source term in ddt(Nd+). Units [m^-3/s], source: examples/tokamak-1D/1D-threshold/BOUT.inp
source_time_dependent = false		# type: bool, doc: Use a time-dependent source?, source: default

[Pd]
evolve_bndry = false		# type: bool, source: default
function = 0.0001		# type: string, source: examples/tokamak-1D/1D-threshold/BOUT.inp
neumann_boundary_average_z = false		# type: bool, doc: Apply neumann boundary with Z average?, source: default
source = <Field3D>		# type: Field3D, doc: Source term in ddt(Pd). Units [Pa/s], note P = 2/3 E, source: default
source_only_in_core = false		# type: bool, doc: Zero the source outside the closed field-line region?, source: default
source_time_dependent = false		# type: bool, doc: Use a time-dependent source?, source: default

[Pd+]
evolve_bndry = false		# type: bool, source: default
function = 1		# type: string, source: examples/tokamak-1D/1D-threshold/BOUT.inp
neumann_boundary_average_z = false		# type: bool, doc: Apply neumann boundary with Z average?, source: default
powerflux = 2.5e7		# source: examples/tokamak-1D/1D-threshold/BOUT.inp
source = (powerflux*2/3 / (mesh:length_xpt))*H(mesh:y_xpt - y)		# type: Field3D, doc: Source term in ddt(Pd+). Units [Pa/s], note P = 2/3 E, source: examples/tokamak-1D/1D-threshold/BOUT.inp
source_only_in_core = false		# type: bool, doc: Zero the source outside the closed field-line region?, source: default
source_time_dependent = false		# type: bool, doc: Use a time-dependent source?, source: default

[Pe]
evolve_bndry = false		# type: bool, source: default
function = `Pd+:function`		# type: string, source: examples/tokamak-1D/1D-threshold/BOUT.inp
neumann_boundary_average_z = false		# type: bool, doc: Apply neumann boundary with Z average?, source: default
source = `Pd+:source`		# type: Field3D, doc: Source term in ddt(Pe). Units [Pa/s], note P = 2/3 E, source: examples/tokamak-1D/1D-threshold/BOUT.inp
source_only_in_core = false		# type: bool, doc: Zero the source outside the closed field-line region?, source: default
source_time_dependent = false		# type: bool, doc: Use a time-dependent source?, source: default

[all]
bndry_all = dirichlet		# type: string, source: default
evolve_bndry = false		# type: bool, source: default
function = 0.0		# type: string, source: default
scale = 1		# type: BoutReal, source: default

[collisions]
diagnose = false		# type: bool, doc: Output additional diagnostics?, source: default
ei_multiplier = 1		# type: BoutReal, doc: User-set arbitrary multiplier on electron-ion collision rate, source: default
electron_electron = true		# type: bool, doc: Include electron-electron collisions?, source: default
electron_ion = true		# type: bool, doc: Include electron-ion collisions?, source: default
electron_neutral = false		# type: bool, doc: Include electron-neutral elastic collisions?, source: default
frictional_heating = true		# type: bool, doc: Include R dot v heating term as energy source?, source: default
ion_ion = true		# type: bool, doc: Include ion-ion elastic collisions?, source: default
ion_neutral = false		# type: bool, doc: Include ion-neutral elastic collisions?, source: default
neutral_neutral = true		# type: bool, doc: Include neutral-neutral elastic collisions?, source: default

[d]
AA = 2		# doc: Particle atomic mass. Proton = 1, source: examples/tokamak-1D/1D-threshold/BOUT.inp
K_cx_multiplier = 1		# type: BoutReal, doc: Scale the charge exchange rate by this factor, source: default
K_iz_multiplier = 1		# type: BoutReal, doc: Scale the ionisation rate by this factor, source: default
K_rec_multiplier = 1		# type: BoutReal, doc: Scale the recombination rate by this factor, source: default
R_ex_multiplier = 1		# type: BoutReal, doc: Scale the ionisation excitation/de-excitation radiation rate by this factor, source: default
R_rec_multiplier = 1		# type: BoutReal, doc: Scale the recombination radiation (incl. 3 body) rate by this factor, source: default
bndry_flux = true		# type: bool, doc: Allow flows through radial boundaries, source: default
charge = 0		# doc: Particle charge. electrons = -1, source: examples/tokamak-1D/1D-threshold/BOUT.inp
conduction_collisions_mode = multispecies		# type: string, doc: Can be multispecies: all collisions, or braginskii: self collisions and ie, source: default
damp_p_nt = false		# type: bool, doc: Damp P - N*T? Active when P < 0 or N < density_floor, source: default
density_floor = 1e-5		# type: BoutReal, doc: Minimum density floor, source: examples/tokamak-1D/1D-threshold/BOUT.inp
diagnose = true		# type: bool, doc: Output additional diagnostics?, source: examples/tokamak-1D/1D-threshold/BOUT.inp
evolve_log = false		# type: bool, doc: Evolve the logarithm of pressure?, source: default
fix_momentum_boundary_flux = false		# type: bool, doc: Fix Y boundary momentum flux to boundary midpoint value?, source: default
hyper_z = -1		# type: BoutReal, doc: Hyper-diffusion in Z, source: default
hyper_z_T = -1		# type: BoutReal, doc: 4th-order dissipation of temperature, source: default
kappa_coefficient = 2.5		# type: BoutReal, doc: Numerical coefficient in parallel heat conduction. Default is 3.16/sqrt(2) for electrons, 2.5 for neutrals and 3.9 otherwise, source: default
kappa_limit_alpha = -1		# type: BoutReal, doc: Flux limiter factor. < 0 means no limit. Typical is 0.2 for electrons, 1 for ions., source: default
low_T_diffuse_perp = false		# type: bool, doc: Add cross-field diffusion at low temperature?, source: default
low_n_diffuse = false		# type: bool, doc: Parallel diffusion at low density, source: default
low_n_diffuse_perp = false		# type: bool, doc: Perpendicular diffusion at low density, source: default
low_p_diffuse_perp = false		# type: bool, doc: Perpendicular diffusion at low pressure, source: default
noflow_lower_y = true		# type: bool, doc: No-flow boundary on lower y?, source: default
noflow_upper_y = true		# type: bool, doc: No-flow boundary on upper y?, source: default
numerical_viscous_heating = false		# type: bool, doc: Include heating due to numerical viscosity?, source: default
p_div_v = false		# type: bool, doc: Use p*Div(v) form? Default, false => v * Grad(p) form, source: default
poloidal_flows = true		# type: bool, doc: Include poloidal ExB flow, source: default
precondition = true		# type: bool, doc: Enable preconditioner? (Note: solver may not use it), source: default
temperature_floor = 0.1		# type: BoutReal, doc: Low temperature scale for low_T_diffuse_perp, source: default
thermal_conduction = true		# type: bool, doc: Include parallel heat conduction?, source: examples/tokamak-1D/1D-threshold/BOUT.inp
type = (evolve_density, evolve_pressure, evolve_momentum,noflow_boundary)		# source: examples/tokamak-1D/1D-threshold/BOUT.inp

[d+]
AA = 2		# doc: Particle atomic mass. Proton = 1, source: examples/tokamak-1D/1D-threshold/BOUT.inp
bndry_flux = true		# type: bool, doc: Allow flows through radial boundaries, source: default
charge = 1		# doc: Particle charge. electrons = -1, source: examples/tokamak-1D/1D-threshold/BOUT.inp
conduction_collisions_mode = multispecies		# type: string, doc: Can be multispecies: all collisions, or braginskii: self collisions and ie, source: default
damp_p_nt = false		# type: bool, doc: Damp P - N*T? Active when P < 0 or N < density_floor, source: default
density_controller_i = 1e-2		# type: BoutReal, doc: Feedback controller integral (i) parameter, source: examples/tokamak-1D/1D-threshold/BOUT.inp
density_controller_p = 5e2		# type: BoutReal, doc: Feedback controller proportional (p) parameter, source: examples/tokamak-1D/1D-threshold/BOUT.inp
density_floor = 1e-07		# type: BoutReal, doc: Minimum density floor, source: default
density_integral_positive = false		# type: bool, doc: Force integral term to be positive?, source: default
density_source_positive = false		# type: bool, doc: Force source to be positive?, source: examples/tokamak-1D/1D-threshold/BOUT.inp
density_upstream = 5e19		# doc: Upstream density (at y=0) [m^-3], source: examples/tokamak-1D/1D-threshold/BOUT.inp
diagnose = true		# type: bool, doc: Save additional diagnostics?, source: examples/tokamak-1D/1D-threshold/BOUT.inp
evolve_log = false		# type: bool, doc: Evolve the logarithm of pressure?, source: default
fix_momentum_boundary_flux = false		# type: bool, doc: Fix Y boundary momentum flux to boundary midpoint value?, source: default
hyper_z = -1		# type: BoutReal, doc: Hyper-diffusion in Z, source: default
hyper_z_T = -1		# type: BoutReal, doc: 4th-order dissipation of temperature, source: default
kappa_coefficient = 3.9		# type: BoutReal, doc: Numerical coefficient in parallel heat conduction. Default is 3.16/sqrt(2) for electrons, 2.5 for neutrals and 3.9 otherwise, source: default
kappa_limit_alpha = -1		# type: BoutReal, doc: Flux limiter factor. < 0 means no limit. Typical is 0.2 for electrons, 1 for ions., source: default
low_T_diffuse_perp = false		# type: bool, doc: Add cross-field diffusion at low temperature?, source: default
low_n_diffuse = false		# type: bool, doc: Parallel diffusion at low density, source: default
low_n_diffuse_perp = false		# type: bool, doc: Perpendicular diffusion at low density, source: default
low_p_diffuse_perp = false		# type: bool, doc: Perpendicular diffusion at low pressure, source: default
neutral_pump = false		# type: bool, doc: Neutral pump enabled? Note, need location in grid file, source: default
noflow_lower_y = true		# type: bool, doc: No-flow boundary on lower y?, source: examples/tokamak-1D/1D-threshold/BOUT.inp
noflow_upper_y = false		# type: bool, doc: No-flow boundary on upper y?, source: examples/tokamak-1D/1D-threshold/BOUT.inp
numerical_viscous_heating = false		# type: bool, doc: Include heating due to numerical viscosity?, source: default
p_div_v = false		# type: bool, doc: Use p*Div(v) form? Default, false => v * Grad(p) form, source: default
pfr_fast_recycle_energy_factor = 0		# type: BoutReal, doc: Fraction of energy retained by fast recycled neutrals at pfr, source: default
pfr_fast_recycle_fraction = 0		# type: BoutReal, doc: Fraction of ions undergoing fast reflection at pfr, source: default
pfr_recycle = false		# type: bool, doc: Recycling in the PFR edge?, source: default
pfr_recycle_energy = 3		# type: BoutReal, doc: Fixed energy of the recycled particles at pfr [eV], source: default
pfr_recycle_multiplier = 1		# type: BoutReal, doc: Multiply the pfr recycled flux by this factor. Should be >=0 and <= 1, source: default
poloidal_flows = true		# type: bool, doc: Include poloidal ExB flow, source: default
precondition = true		# type: bool, doc: Enable preconditioner? (Note: solver may not use it), source: default
pump_recycle_multiplier = 1		# type: BoutReal, doc: Multiply the pump boundary recycling flux by this factor (like albedo). Should be >=0 and <= 1, source: default
recycle_as = d		# doc: Name of the species to recycle into, source: examples/tokamak-1D/1D-threshold/BOUT.inp
sol_fast_recycle_energy_factor = 0		# type: BoutReal, doc: Fraction of energy retained by fast recycled neutrals at sol, source: default
sol_fast_recycle_fraction = 0		# type: BoutReal, doc: Fraction of ions undergoing fast reflection at sol, source: default
sol_recycle = false		# type: bool, doc: Recycling in the SOL edge?, source: default
sol_recycle_energy = 3		# type: BoutReal, doc: Fixed energy of the recycled particles at sol [eV], source: default
sol_recycle_multiplier = 1		# type: BoutReal, doc: Multiply the sol recycled flux by this factor. Should be >=0 and <= 1, source: default
target_fast_recycle_energy_factor = 0		# type: BoutReal, doc: Fraction of energy retained by fast recycled neutrals at target, source: default
target_fast_recycle_fraction = 0		# type: BoutReal, doc: Fraction of ions undergoing fast reflection at target, source: default
target_recycle = true		# type: bool, doc: Recycling in the targets?, source: examples/tokamak-1D/1D-threshold/BOUT.inp
target_recycle_energy = 3.5		# type: BoutReal, doc: Fixed energy of the recycled particles at target [eV], source: examples/tokamak-1D/1D-threshold/BOUT.inp
target_recycle_multiplier = 1		# type: BoutReal, doc: Multiply the target recycled flux by this factor. Should be >=0 and <= 1, source: examples/tokamak-1D/1D-threshold/BOUT.inp
temperature_floor = 0.1		# type: BoutReal, doc: Low temperature scale for low_T_diffuse_perp, source: default
thermal_conduction = true		# type: bool, doc: Include parallel heat conduction?, source: examples/tokamak-1D/1D-threshold/BOUT.inp
type = (evolve_density, evolve_pressure, evolve_momentum,noflow_boundary, upstream_density_feedback)		# source: examples/tokamak-1D/1D-threshold/BOUT.inp

[e]
AA = 1/1836		# doc: Particle atomic mass. Proton = 1, source: examples/tokamak-1D/1D-threshold/BOUT.inp
bndry_flux = true		# type: bool, doc: Allow flows through radial boundaries, source: default
charge = -1		# doc: Particle charge. electrons = -1, source: examples/tokamak-1D/1D-threshold/BOUT.inp
conduction_collisions_mode = multispecies		# type: string, doc: Can be multispecies: all collisions, or braginskii: self collisions and ie, source: default
damp_p_nt = false		# type: bool, doc: Damp P - N*T? Active when P < 0 or N < density_floor, source: default
density_floor = 1e-07		# type: BoutReal, doc: Minimum density floor, source: default
diagnose = true		# type: bool, doc: Save additional output diagnostics, source: examples/tokamak-1D/1D-threshold/BOUT.inp
evolve_log = false		# type: bool, doc: Evolve the logarithm of pressure?, source: default
hyper_z = -1		# type: BoutReal, doc: Hyper-diffusion in Z, source: default
hyper_z_T = -1		# type: BoutReal, doc: 4th-order dissipation of temperature, source: default
kappa_coefficient = 2.23446		# type: BoutReal, doc: Numerical coefficient in parallel heat conduction. Default is 3.16/sqrt(2) for electrons, 2.5 for neutrals and 3.9 otherwise, source: default
kappa_limit_alpha = -1		# type: BoutReal, doc: Flux limiter factor. < 0 means no limit. Typical is 0.2 for electrons, 1 for ions., source: default
low_T_diffuse_perp = false		# type: bool, doc: Add cross-field diffusion at low temperature?, source: default
low_n_diffuse_perp = false		# type: bool, doc: Perpendicular diffusion at low density, source: default
low_p_diffuse_perp = false		# type: bool, doc: Perpendicular diffusion at low pressure, source: default
noflow_lower_y = true		# type: bool, doc: No-flow boundary on lower y?, source: default
noflow_upper_y = false		# type: bool, doc: No-flow boundary on upper y?, source: examples/tokamak-1D/1D-threshold/BOUT.inp
numerical_viscous_heating = false		# type: bool, doc: Include heating due to numerical viscosity?, source: default
p_div_v = false		# type: bool, doc: Use p*Div(v) form? Default, false => v * Grad(p) form, source: default
poloidal_flows = true		# type: bool, doc: Include poloidal ExB flow, source: default
precondition = true		# type: bool, doc: Enable preconditioner? (Note: solver may not use it), source: default
temperature_floor = 0.1		# type: BoutReal, doc: Low temperature scale for low_T_diffuse_perp, source: default
thermal_conduction = true		# type: bool, doc: Include parallel heat conduction?, source: examples/tokamak-1D/1D-threshold/BOUT.inp
type = quasineutral, evolve_pressure, zero_current, noflow_boundary		# source: examples/tokamak-1D/1D-threshold/BOUT.inp

[electromagnetic:laplacian]
atol_accept = 1e-06		# unused value (NOT marked conditionally used), type: BoutReal, source: user_default
maxits = 1000		# unused value (NOT marked conditionally used), type: int, source: user_default
rtol_accept = 0.01		# unused value (NOT marked conditionally used), type: BoutReal, source: user_default
type = naulin		# unused value (NOT marked conditionally used), type: string, source: user_default

[electron_force_balance]
diagnose = false		# type: bool, doc: Save additional output diagnostics, source: default

[fft]
fft_measurement_flag = estimate		# type: 20FFT_MEASUREMENT_FLAG, doc: Level speed measurements to optimise FFT settings: [estimate], measure, exhaustive, source: default

[hermes]
Bnorm = 1		# type: BoutReal, doc: Reference magnetic field [T], source: examples/tokamak-1D/1D-threshold/BOUT.inp
Nnorm = 1e19		# type: BoutReal, doc: Reference density [m^-3], source: examples/tokamak-1D/1D-threshold/BOUT.inp
Tnorm = 100		# type: BoutReal, doc: Reference temperature [eV], source: examples/tokamak-1D/1D-threshold/BOUT.inp
components = (d+, d, e,sheath_boundary_simple, collisions, recycling, reactions,electron_force_balance, neutral_parallel_diffusion)		# doc: Components in order of execution, source: examples/tokamak-1D/1D-threshold/BOUT.inp
normalise_metric = true		# type: bool, doc: Normalise input metric tensor? (assumes input is in SI units), source: examples/tokamak-1D/1D-threshold/BOUT.inp
recalculate_metric = false		# type: bool, doc: Load Rxy, Bpxy etc. to calculate an orthogonal metric?, source: default
restarting = false		# unused value (marked conditionally used)
revision = bb1dfc1dfad0c4a106b3db308088d4c0c81e3a64		# unused value (marked conditionally used)
slope_limiter = MC		# unused value (marked conditionally used)

[input]
error_on_unused_options = true		# type: bool, doc: Error if there are any unused options before starting the main simulation, source: default
max_recursion_depth = 0		# type: string, doc: Maximum recursion depth allowed in expressions. 0 = no recursion; -1 = unlimited, source: default
transform_from_field_aligned = true		# type: string, source: default
validate = false		# type: bool, doc: Check for unused options and stop, source: default

[mesh]
J = 1		# source: examples/tokamak-1D/1D-threshold/BOUT.inp
calcParallelSlices_on_communicate = false		# type: bool, doc: Calculate parallel slices on all communicated fields, source: user_default
dy = (length / ny) * (1 + (1-dymin)*(1-y/pi))		# source: examples/tokamak-1D/1D-threshold/BOUT.inp
dymin = 0.1		# source: examples/tokamak-1D/1D-threshold/BOUT.inp
extrapolate_x = false		# type: bool, source: default
extrapolate_y = false		# type: bool, source: default
include_corner_cells = true		# type: bool, doc: Communicate corner guard and boundary cells. Can be set to false if you are sure that you will not need these cells, for mixed derivatives D2DXDY (or anything else), for example if your grid has orthogonal x- and y-directions. This might slightly reduce communication time., source: default
ixseps1 = -1		# source: examples/tokamak-1D/1D-threshold/BOUT.inp
ixseps2 = -1		# source: examples/tokamak-1D/1D-threshold/BOUT.inp
length = 30		# source: examples/tokamak-1D/1D-threshold/BOUT.inp
length_xpt = 10		# source: examples/tokamak-1D/1D-threshold/BOUT.inp
maxregionblocksize = 64		# type: int, doc: (Advanced) Sets the maximum size of continguous blocks when creating Regions, source: default
nx = 1		# source: examples/tokamak-1D/1D-threshold/BOUT.inp
ny = 400		# source: examples/tokamak-1D/1D-threshold/BOUT.inp
nz = 1		# source: examples/tokamak-1D/1D-threshold/BOUT.inp
source = length_xpt / length		# source: examples/tokamak-1D/1D-threshold/BOUT.inp
staggergrids = false		# type: bool, doc: Enable staggered grids. By default, all variables are cell centred, source: default
symmetricGlobalX = true		# type: bool, source: default
symmetricGlobalY = true		# type: bool, source: default
type = bout		# type: string, source: default
y_xpt = pi * ( 2 - dymin - sqrt( (2-dymin)^2 - 4*(1-dymin)*source ) ) / (1 - dymin)		# source: examples/tokamak-1D/1D-threshold/BOUT.inp

[mesh:ddz]
fft_filter = 0		# type: BoutReal, source: default

[mesh:paralleltransform]
type = identity		# type: string, source: default

[neutral_parallel_diffusion]
diagnose = false		# type: bool, doc: Output additional diagnostics?, source: default
diffusion_collisions_mode = afn		# type: string, doc: Can be afn: CX and IZ, or multispecies: CX and nn, ni, ne (if enabled), source: default
dneut = 10		# doc: cross-field diffusion projection (B  / Bpol)^2, source: examples/tokamak-1D/1D-threshold/BOUT.inp
equation_fix = true		# type: bool, doc: Fix correcting pressure advection and conductivity factors?, source: default
perpendicular_conduction = true		# type: bool, doc: Enable parallel projection of perpendicular conduction?, source: default
perpendicular_viscosity = true		# type: bool, doc: Enable parallel projection of perpendicular viscosity?, source: default

[output]
append = false		# type: bool, doc: Append to existing file?, source: user_default
enabled = true		# type: bool, doc: Write output files, source: default
path = examples/tokamak-1D/1D-threshold/		# type: string, source: user_default
prefix = BOUT.dmp		# type: string, source: user_default
type = netcdf		# type: string, source: default

[pardiv]
type = cyclic		# type: string, source: default

[reactions]
diagnose = true		# type: bool, doc: Output additional diagnostics?, source: examples/tokamak-1D/1D-threshold/BOUT.inp
no_neutral_cx_mom_gain = false		# type: bool, doc: If true, ion momentum in CX is still lost but not given to the neutrals, source: default
type = (d + e -> d+ + 2e,d+ + e -> d,d + d+ -> d+ + d,)		# source: examples/tokamak-1D/1D-threshold/BOUT.inp

[recycling]
density_floor = 1e-07		# type: BoutReal, doc: Minimum density floor, source: default
species = d+		# doc: Comma-separated list of species to recycle, source: examples/tokamak-1D/1D-threshold/BOUT.inp

[restart_files]
append = false		# type: bool, doc: Append to existing file?, source: user_default
enabled = true		# type: bool, doc: Write restart files, source: default
path = examples/tokamak-1D/1D-threshold/		# type: string, source: user_default
prefix = BOUT.restart		# type: string, source: user_default
singleWriteFile = true		# unused value (NOT marked conditionally used), type: bool, source: user_default
type = netcdf		# type: string, source: default

[run]
finished = Fri Oct 17 16:59:24 2025
		# unused value (NOT marked conditionally used), source: Output
revision = c4c149a28a63f787302db9671505c7556c19b20d		# unused value (NOT marked conditionally used), source: Output
run_id = 256f15ec-e070-40f8-b879-b5b51261dc8b		# unused value (NOT marked conditionally used), source: Output
run_restart_from = zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz		# unused value (NOT marked conditionally used), source: Output
started = Fri Oct 17 16:52:33 2025
		# unused value (NOT marked conditionally used), source: Output
version = 5.1.2.dev982+gc4c149a28		# unused value (NOT marked conditionally used), source: Output

[sheath_boundary_simple]
always_set_phi = false		# type: bool, doc: Always set phi field? Default is to only modify if already set, source: default
density_boundary_mode = 1		# type: BoutReal, doc: BC mode: 0=LimitFree, 1=ExponentialFree, 2=LinearFree, source: default
diagnose = false		# type: bool, doc: Save additional output diagnostics, source: default
gamma_e = 3.5		# type: BoutReal, doc: Electron sheath heat transmission coefficient, source: examples/tokamak-1D/1D-threshold/BOUT.inp
gamma_i = 3.5		# type: BoutReal, doc: Ion sheath heat transmission coefficient, source: examples/tokamak-1D/1D-threshold/BOUT.inp
lower_y = false		# type: bool, doc: Boundary on lower y?, source: examples/tokamak-1D/1D-threshold/BOUT.inp
no_flow = false		# type: bool, doc: Set zero particle flow, keeping energy flow, source: default
pressure_boundary_mode = 1		# type: BoutReal, doc: BC mode: 0=LimitFree, 1=ExponentialFree, 2=LinearFree, source: default
secondary_electron_coef = 0		# type: BoutReal, doc: Effective secondary electron emission coefficient, source: default
sheath_ion_polytropic = 1		# type: BoutReal, doc: Ion polytropic coefficient in Bohm sound speed, source: default
sin_alpha = 1		# type: BoutReal, doc: Sin of the angle between magnetic field line and wall surface. Should be between 0 and 1, source: default
temperature_boundary_mode = 1		# type: BoutReal, doc: BC mode: 0=LimitFree, 1=ExponentialFree, 2=LinearFree, source: default
upper_y = true		# type: bool, doc: Boundary on upper y?, source: examples/tokamak-1D/1D-threshold/BOUT.inp
wall_potential = <Field3D>		# type: Field3D, doc: Voltage of the wall [Volts], source: default

[solver]
adams_moulton = false		# type: bool, doc: Use Adams Moulton implicit multistep. Otherwise BDF method., source: default
apply_positivity_constraints = false		# type: bool, doc: Use CVODE function CVodeSetConstraints to constrain variables - the constraint to be applied is set by the positivity_constraint option in the subsection for each variable, source: default
atol = 1e-7		# type: BoutReal, doc: Absolute tolerance, source: examples/tokamak-1D/1D-threshold/BOUT.inp
cvode_linear_convergence_coef = 0.05		# type: BoutReal, doc: Factor by which the Krylov linear solver’s convergence test constant is reduced from the nonlinear solver test constant., source: default
cvode_max_order = -1		# type: int, doc: Maximum order of method to use. <= 0 means default limit., source: default
cvode_nonlinear_convergence_coef = 0.1		# type: BoutReal, doc: Safety factor used in the nonlinear convergence test, source: default
cvode_stability_limit_detection = false		# type: bool, source: default
diagnose = false		# type: bool, doc: Print solver diagnostic information?, source: default
func_iter = false		# type: bool, doc: Use functional iteration instead of Newton, source: default
is_nonsplit_model_diffusive = true		# type: bool, doc: If not a split operator, treat RHS as diffusive?, source: default
linear_solver = gmres		# type: 13linear_solver, doc: Set linear solver type. Default is gmres., source: default
max_nonlinear_iterations = 3		# type: int, doc: Maximum number of nonlinear iterations allowed by CVODE before reducing timestep., source: default
max_timestep = 0		# type: BoutReal, doc: Maximum time step size, source: default
maxl = 5		# type: int, doc: Maximum number of linear iterations, source: default
min_timestep = 0		# type: BoutReal, doc: Minimum time step size, source: default
mms = false		# type: bool, doc: Use Method of Manufactured Solutions to track error scaling, source: default
mms_initialise = false		# type: bool, doc: Use MMS solution for field initial conditions, source: default
monitor_timestep = false		# type: bool, doc: Call monitors on internal timesteps, source: default
mxorder = 3		# type: int, doc: Maximum order, source: examples/tokamak-1D/1D-threshold/BOUT.inp
mxstep = 1e9		# type: int, doc: Maximum number of internal steps between outputs., source: examples/tokamak-1D/1D-threshold/BOUT.inp
nout = 50		# type: int, doc: Number of output steps. Overrides global setting., source: default
output_step = 4789.4		# type: BoutReal, doc: Output time step size. Overrides global 'timestep' setting., source: default
rightprec = false		# type: bool, doc: Use right preconditioner? Otherwise use left., source: default
rtol = 1e-5		# type: BoutReal, doc: Relative tolerance, source: examples/tokamak-1D/1D-threshold/BOUT.inp
save_repeat_run_id = false		# type: bool, doc: Write run_id and run_restart_from at every output timestep, to make it easier to concatenate output data sets in time, source: default
start_timestep = 0		# type: BoutReal, doc: Starting time step. = 0 then chosen by CVODE., source: default
type = cvode		# type: string, source: examples/tokamak-1D/1D-threshold/BOUT.inp
use_jacobian = false		# type: bool, source: default
use_precon = true		# type: bool, doc: Use preconditioner?, source: examples/tokamak-1D/1D-threshold/BOUT.inp
use_vector_abstol = false		# type: bool, doc: Use separate absolute tolerance for each field, source: default
Tesla = 1		# unused value (marked conditionally used)
eV = 100
inv_meters_cubed = 1e+19
meters = 0.00102175
seconds = 1.04397e-08
